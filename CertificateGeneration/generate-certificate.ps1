. ".\password-utils.ps1"
. ".\certificate-utils.ps1"

# Ask for certificate name.
$name = Read-Host "Enter certifiacte name"
Write-Host "  -> $name"
$certStore = "cert:\CurrentUser\My"
$exportDirPath = ".secrets.$name"
$certFilePathPart = "$exportDirPath\$name"

Remove-Item $exportDirPath -Recurse -Force

#region Checks
# Check existing output folder.
if (Test-Path $exportDirPath) {
    Write-Warning ("The outputfolder does already exit (.\$exportDirPath). " +
        "The program will not overwrite existing data. " +
        "Please rename, move or delete the existing folder.")
    return
}

$certificates = Get-CertificatesByName -Name $name -Store $certStore
if ($certificates) {
    # Print duplicate certificates.
    Write-Warning "Found installed certificates with same name: (Name: '$name', Store: '$certStore')"
    $certificates | Format-List

    # Write warning.
    Write-Warning ("A certificate with the same name is already installed. (Name: '$name', Store: '$certStore')")
    Write-Host "  Certificates with the same name are confusing but works for the computer."
    
    # Ask proceed.
    $duplicateResponse = Read-Host "Do you want to proceed? (y|n) "
    if ($duplicateResponse -eq 'Y' -or $duplicateResponse -eq 'y') {
        Write-Host "  -> yes proceeding with the operation."
    } else {
        Write-Host "  Operation canceled."
        return 
    }
} 
#endregion
#region Enddate
# Ask enddate.
$endDate = (Get-Date).AddDays(15000) # today + ~41.096 years
$endDateResponse = Read-Host "Enter end-date-offset in days [now + offset] (default: $endDate (15'000, ~41.096y))"
if ($endDateResponse -match "^[\d\.]+$") {
    $endDate = (Get-Date).AddDays($endDateResponse) # today + ~41.096 years
    Write-Host "  -> $endDate ($endDateResponse)"
} else {
    Write-Host "  -> '$endDateResponse' is no valid number. Take default $endDate (15'000)"
}
#endregion

#region Password
$pw = "failed-to-read-user-password"
$passwordResponse = Read-Host "Leave blank for strong autogenerated password or type your own password"
if ($passwordResponse) {
    $pw = $passwordResponse
} else {
    $pw = Start-GeneratePassword -Length 30
}
Write-Host "  -> '$pw'"
$password = ConvertTo-SecureString -String $pw -AsPlainText -Force -ErrorAction Stop
#endregion

# Create export folder.
New-Item $exportDirPath -ItemType Directory | Out-Null
Write-Host "  Export folder created '$exportDirPath'\"

# Create and export certificate.
$cert = Start-CreateAndInstallCertificate -Name $name -EndDate $endDate -CertStore $certStore

Start-ExportPublicKey -CertFilePathPart $certFilePathPart -Certificate $cert
Start-ExportPrivateKey -CertFilePathPart $certFilePathPart -Certificate $cert -Password $password
Start-ExportCertificateProperties -CertFilePathPart $certFilePathPart -Certificate $cert -Password $password

# Ask deinstall certificate.
$deinstallResponse = Read-Host "Do you want to deinstall the certificate? (y|n) "
if ($deinstallResponse -eq 'Y' -or $deinstallResponse -eq 'y') {
    Write-Host "  -> yes (deinstall certificate)"
    Remove-Certificate -Thumbprint $cert.Thumbprint -Store $certStore
}

# Ask open export folder.
$openFolderResponse = Read-Host "Do you want to open the export folder? (y|n) "
if ($openFolderResponse -eq 'Y' -or $openFolderResponse -eq 'y') {
    Write-Host "  -> yes (open export folder)"
    Invoke-Item $exportDirPath
}